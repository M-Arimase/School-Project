## 数据结构与算法
### 第七章 习题
***
#### `1`
> 证明：只要适当地排列顶点的次序，就能使有向无环图的邻接矩阵中主对角线以下的元素全部为0。

对于任意有向无环图$G(V,E)$，一定存在至少一个拓扑序，按照拓扑序对顶点重标号，则对于任意的边$(U,V)$都有$U\le V$，即不存在一条边$(U,V)$使得$U>V$，即邻接矩阵中$a_{ij}=0,\forall i>j$，即邻接矩阵主对角线以下的元素全部为$0$。
***
#### `2`
> Dr.Stranger的电脑染上了一种特殊的病毒，该病毒发作时会将字母用其他字母代替，但不会将单词顺序交换，也不会产生新的字母。在病毒发作前文档D中的单词顺序为字典排序（比如在字典序下单词ab会排在单词ac前），且文档D中所有的单词只由字母集合{a，b，c，d，e}中的字母组成，病毒发作后文档D中的所有单词顺序如下：{cebdbac，cac，ecd，dca，aba，bac}，求文档D在病毒发作前的内容，并说明解题思路和步骤。

原内容为$\{ abeceda,ada,bac,cad,ded,eda\}$，只用观察首字符就知道了字符之前的偏序关系，即$\{ c=a,e=b,d=c,a=d,b=e\}$，一一替换即可。
***
#### `3`
> Toole教授提出了一种新的分治算法来计算最小生成树，该算法是这样的：给定一个图G=(V, E)，将顶点集合V划分成两个集合V1和V2，使得| V1|和| V2|至多差1。设E1为一个边集，其中的边都与V1中的顶点关联，E2为另一个边集，其中的边都与V2中的顶点关联。在两个子图G1=(V1, E1)和G2=(V2, E2)上，分别递归地解决最小生成树问题。最后，从E中选择一条通过割(V1, V2)（两个端点分别在V1和V2上）的最小权边，并利用该边，将所得的两棵最小生成树合并成一棵完整的生成树。请论证该算法能正确地计算出G的最小生成树，或者给出一个使该算法不能正确工作的例子。

反例：

![Picture](http://img2.ph.126.net/igA3yCBNM3jVDQK_k02R4w==/6632713734606502007.jpg)

$V1=\{ A,B\},V2=\{ C,D\}$则最小生成树大小为$201$显然错误。

***
#### `4`
> 单源最短路径问题中，当路径中存在负权边时(不存在负权回路)不可以使用Dijkstra算法：(注：题中分析时间复杂度时，默认存储结构是邻接表，且使用最小堆存储源点到各点的路径值)
> 
> 一种想法是：先在每条边上加上一个常数，从而消除负权边，然后再利用Dijkstra算法。请问这种算法可行吗？若可行，请说明理由并分析时间复杂度；若不可行，请举反例。

反例：

![Picture](http://img2.ph.126.net/YLTQlRRCPCtaLGhssbAr1A==/6632555404934700017.jpg)

每条边边权加上$100$以后最短路为$A\rightarrow E$显然错误。
> 另外一种想法是：利用Dijkstra算法，在算法运行过程中，若w已经在S中，但是由于与w相邻的点加入S中而新计算得到的dist[w]比S中存储的dist[w]还要小，那么将w从S中剔除，重新加入未知集合T中。请问这种算法可行吗？若可行，请说明理由并分析时间复杂度；若不可行，请举反例。

理由：

先说明$3$个证明中会用到的引理，比较显然所以不加以证明。

引理$1$：若存在一个时刻，$w$在队列中且$dist[w]=dist_w$，则算法结束后$dist[w]\le dist_w$

引理$2$：若存在一个时刻，$w$在队列中且$dist[w]=dist_w$，则$w$出队列时$dist[w]\le dist_w$

引理$3$：如存在一个时刻，$dist[w]=dist_w$，则在这之前一定存在一个时刻，$w$在队列中且$dist'[w]=dist_w$

记$Start$到$w$的最短路径长度为$dist_{min(w)}$，最短路径上经过的边数记为$edge_{min(w)}$，并将$<edge_{min(w)},w,dist_{min(w)}>$记为$P_i$。将$P_i$按照第一元素为关键字排序，我们证明$\forall P_i$一定存在一个时刻，$P_i.w$在队列中并且$dist[P_i.w]\le P_i.dist$。

可以知道$P_0=<0,Start,0>$,当$Start$加入队列时显然$dist[Start]\le 0$。

若$\forall i<K$命题成立，令$w=P_K.w,e=P_K.edge,d=P_K.dist$，则从$Start$到$w$的最短路径是$Start\rightarrow W_1\rightarrow W_2\rightarrow ...\rightarrow W_{e-1}\rightarrow w$且长度为$d$，令$d_1=d-dist(W_{e-1}\rightarrow w)$。我们有从$Start$到$W_{e-1}$的最短路径是$Start\rightarrow W_1\rightarrow W_2\rightarrow ...\rightarrow W_{e-1}$且长度为$d_1$、经过的边数为$e-1$，则$<e-1,W_{e-1},d_1>$在$P_K$之前。根据归纳假设，一定存在一个时刻，$W_{e-1}$在队列中并且$dist[W_{e-1}]\le d_1$，由于队列最后是空的，那么一定存在一个时刻$W_{e-1}$出队列，由引理$2$知此时$dist[W_{e-1}]\le d_1$，由于存在边$W_{e-1}\rightarrow w$，算法会用$d_1+dist(W_{e-1}\rightarrow w)=d$去更新$dist[w]$，分$3$种情况讨论。

* 若更新成功且此时$w$不在队列中，即$w\in S$，则将$w$从$S$总删除并加入$T$，同时会将$w$加入队列中。此时$w$在队列中且$dist[w]=d$
* 若更新成功且此时$w$在队列中，则此时$w$在队列中且$dist[w]=d$
* 若更新不成功，即$dist[w]<d$，由引理$3$知，在这之前一定存在一个时刻，$w$在队列中且$dist'[w]=dist[w]<d$

综上，对于$K$命题成立，故$\forall i<V$命题成立。由引理$1$知算法结束后$\forall i,dist[i]\le dist_{min(i)}$，又因为$dist[i]\ge dist_{min(i)}$，故$dist[i]=dist_{min(i)}$。

复杂度大概为$O(V\times 2^V)$。
***
#### `5`
> 套汇是指利用汇率差异将一个单位的货币转换为大于一个单位的同种货币。例如，假设1美元兑换7.51人民币，1元人民币兑换0.07英镑，1英镑兑换2.03美元，那么如果一个人拿1美元先兑换成人民币，再把人民币兑换成英镑，最后把英镑兑换成美元，则他最后能够得到1*7.51*0.07*2.03=1.07美元，从而获得1.07-1=0.07美元的利润，这就是套汇。假设有n种货币v1,v2,…,vn和有关汇率的n*n矩阵，其中A[i,j]是一单位货币vi兑换成货币vj的单位数，要求设计一个程序判断是否存在一个货币序列vi1,vi2,…,vik使得A[i1,i2]*A[i2,i3]*…*A[ik,i1] > 1，并确定算法的时间复杂度。

```C++
bool Func(void *Matrix_Ptr, int N) {
        double dist[N][N];

        memcpy(dist, Matrix_Ptr, sizeof(dist));

        double maxRate = 0;
        for (int k = 0; k < N; k++) {
                for (int i = 0; i < N; i++)
                        for (int j = 0; j < N; j++)
                                maxRate = max(maxRate, dist[i][k] * dist[k][j] *
                                                           dist[j][i]);
                for (int i = 0; i < N; i++)
                        for (int j = 0; j < N; j++)
                                dist[i][j] =
                                    max(dist[i][j], dist[i][k] * dist[k][j]);
        }
        return maxRate > 1;
}
```
使用$Floyd$求最大环的方法，时间复杂度$O(N^3)$。
***
